library(tidyverse)
library(prioritizr)
library(gurobi)
library(patchwork)

#############
## Practice
#############

# load data
data(sim_pu_polygons, sim_pu_zones_stack, sim_features, sim_features_zones)

# add a column to contain the penalty data for each planning unit
# e.g. these values could indicate the level of habitat
# set seed for reproducibility
set.seed(600)
sim_pu_polygons$penalty_data <- runif(nrow(sim_pu_polygons))

# creating a constant penalty layer (1)
sim_pu_polygons$penalty_data <- 100

# creating linearly changing penalties
sim_pu_polygons$penalty_data <- c(1:90)

# plot the penalty data to visualise its spatial distribution
spplot(sim_pu_polygons, zcol = "penalty_data", main = "penalty data",
       axes = FALSE, box = FALSE)

# modifying cost layer

# creating a constant cost layer
sim_pu_polygons$cost <- 100

#creating a synthetic cost layer
sim_pu_polygons$cost[1:45] <- 1
sim_pu_polygons$cost[46:90] <- 100

# increasing cost by 10
sim_pu_polygons$cost <- sim_pu_polygons$cost*10

spplot(sim_pu_polygons, zcol = 'cost', main = 'cost',
       axes = FALSE, box = FALSE)

# without the penalties
p1 <- problem(sim_pu_polygons, sim_features, cost_column = "cost") %>%
  add_min_set_objective() %>%
  add_relative_targets(0.1) %>%
  add_binary_decisions() %>%
  add_default_solver(verbose = FALSE)

# print problem
print(p1)

# create an updated version of the previous problem,
# with the penalties added to it
p2 <- p1 %>% add_linear_penalties(1, data = "penalty_data")

# print problem
print(p2)

# solve the two problems
s1 <- solve(p1)
s2 <- solve(p2)

# knowing the total cost for each problem
eval_cost_summary(p1, s1[,'solution_1'])
eval_cost_summary(p2,s2[,'solution_1'])

# mean penalty
yy <- s1 %>% 
  as_tibble() %>% 
  filter(solution_1 == 1)
mean(yy$penalty_data)
xx <- s2 %>% 
  as_tibble() %>% 
  filter(solution_1 == 1)
mean(xx$penalty_data)

# plot the solutions and compare them,
# since we supplied a very high penalty value (i.e. 100), relative
# to the range of values in the penalty data and the objective function,
# the solution in s2 is very sensitive to values in the penalty data
spplot(s1, zcol = "solution_1", main = "solution without penalties",
       axes = FALSE, box = FALSE)
spplot(s2, zcol = "solution_1", main = "solution with penalties; scale = 1",
       axes = FALSE, box = FALSE)

# for real conservation planning exercises,
# it would be worth exploring a range of penalty values (e.g. ranging
# from 1 to 100 increments of 5) to explore the trade-offs
# }

# now, let's examine a conservation planning exercise involving multiple
# management zones

# create targets for each feature within each zone,
# these targets indicate that each zone needs to represent 10% of the
# spatial distribution of each feature
targ <- matrix(0.1, ncol = number_of_zones(sim_features_zones),
               nrow = number_of_features(sim_features_zones))

# create penalty data for allocating each planning unit to each zone,
# these data will be generated by simulating values
penalty_stack <- simulate_cost(sim_pu_zones_stack[[1]],
                               n = number_of_zones(sim_features_zones))
penalty_stack
print(sim_pu_zones_stack)

# plot the penalty data, each layer corresponds to a different zone
plot(penalty_stack, main = "penalty data", axes = FALSE, box = FALSE)

# create a multi-zone problem with the minimum set objective
# and penalties for allocating planning units to each zone,
# with a penalty scaling factor of 1 for each zone
p3 <- problem(sim_pu_zones_stack, sim_features_zones) %>%
  add_min_set_objective() %>%
  add_relative_targets(targ) %>%
  add_linear_penalties(c(1, 1, 1), penalty_stack) %>%
  add_binary_decisions() %>%
  add_default_solver(verbose = FALSE)

# print problem
print(p3)

# solve problem
s3 <- solve(p3)

########################
#### Try with data #####
########################
# Defining the parameters
cost_file <- 'outputs/06_Cost/Large_Medium/costlayer.rds'
commercial_file <- 'outputs/08_Filter/08e_Filter100_NoProv/commercialuninformed_100percentile.rds'
bycatch_file <- 'outputs/08_Filter/08e_Filter100_NoProv/bycatchIUCNuninformed_100percentile.rds'

# Load PUs with the cost (don't really need PUs as cost is complete)
cost_temp <- readRDS(cost_file)
cost <- cost_temp %>% 
  as_tibble()
hist(cost$cost)

# plotting raw values of cost
ggplot() +
  geom_sf(data = cost_temp, aes(fill = cost), color = 'grey20', size = 0.01) +
  geom_sf(data = world_sf, size = 0.05, fill = "grey20") +
  coord_sf(xlim = c(st_bbox(Bndry)$xmin, st_bbox(Bndry)$xmax), 
           ylim = c(st_bbox(Bndry)$ymin, st_bbox(Bndry)$ymax),
           expand = TRUE) +
  theme_bw()

# features
feature1 <- readRDS(bycatch_file) %>% 
  as_tibble() %>% 
  dplyr::select(-geometry)
# Just using 1 feature
feature1 <- feature1 %>% 
  filter(new_features %in% c('Chelonia_mydas_IUCN')) %>%
  as_tibble() %>% 
  dplyr::select(-geometry)

# joining all the features
# A character list of features to analyse
features_list = unique(feature1$new_features) %>% 
  str_sort() # make sure that they are in alphabetical order (to make it consistent)

# Just get species data out in wide format
# pivot the table in a wide format (columns would be the new_features and the values are the presence/absence)
species <- feature1 %>% 
  dplyr::select(c(new_features, cellsID)) %>% 
  mutate(Presence = 1) %>% # if the feature has the particular cellsID, it is present
  pivot_wider(names_from = new_features, values_from = Presence) %>% 
  replace(is.na(.), 0)

# x has the cost, the features, ...
x <- feature1 %>%
  dplyr::select(-new_features) %>% 
  distinct(cellsID, .keep_all = TRUE) %>% 
  left_join(species, by = "cellsID") %>% 
  right_join(cost, by = "cellsID") %>% 
  st_as_sf(sf_column_name = "geometry")

# create penalties using RCE
RCE <- readRDS('outputs/07_Climate/RCE/RCESSP126.rds')
RCE_temp <- RCE %>% 
  as_tibble() %>% 
  dplyr::select(-area_km2, -trans_value, -rce_categ, -geometry)
hist(RCE_temp$value)

# plotting raw values of RCE
ggplot() +
  geom_sf(data = RCE, aes(fill = value), color = 'grey20', size = 0.01) +
  geom_sf(data = world_sf, size = 0.05, fill = "grey20") +
  coord_sf(xlim = c(st_bbox(Bndry)$xmin, st_bbox(Bndry)$xmax), 
           ylim = c(st_bbox(Bndry)$ymin, st_bbox(Bndry)$ymax),
           expand = TRUE) +
  theme_bw()

RCE_filtered <- RCE %>% 
  filter(value < 20)

ggplot() +
  geom_sf(data = RCE_filtered, aes(fill = value, color = value)) +
  geom_sf(data = world_sf, size = 0.05, fill = "grey20") +
  coord_sf(xlim = c(st_bbox(Bndry)$xmin, st_bbox(Bndry)$xmax), 
           ylim = c(st_bbox(Bndry)$ymin, st_bbox(Bndry)$ymax),
           expand = TRUE) +
  theme_bw()

# creating a numeric list of the RCE values as penalty arranged according to cellsID
RCE_penalty_temp <- RCE_temp %>% 
  dplyr::arrange(cellsID)
x_temp <- left_join(x, RCE_penalty_temp, by = 'cellsID') %>% 
  rename(penalty = value)
#x$penalty <- RCE_penalty_temp$value 

# creating base problem
p <- prioritizr::problem(x_temp, features_list, "cost") %>% 
  add_min_set_objective() %>%
  add_relative_targets(0.30) %>%
  add_binary_decisions() %>%
  add_gurobi_solver(gap = 0, verbose = FALSE)

s <- solve(p)
eval_cost_summary(p,s[,'solution_1'])
s_plot <- s %>% 
  st_as_sf(sf_column_name = "geometry") %>%  # Output changes from sf to df so we change it back
  mutate(solution_1 = as.logical(solution_1))

# plotting
pal_rich <- c("FALSE" = "lightsteelblue2", "TRUE" = "sienna3")
solution <- c("Not selected PUs", "Selected PUs")
ggplot() +
  geom_sf(data = s_plot, aes(fill = solution_1), color = 'grey20', size = 0.02) +
  scale_fill_manual(name = "Solution",
                    values = pal_rich,
                    labels = solution) +
  labs(title = 'climate-uninformed')

# adding penalties
p1 <- p %>% 
  add_linear_penalties(4, 'penalty')
s1 <- solve(p1)
eval_cost_summary(p1, s1[,'solution_1'])[2]
zz <- s1 %>% 
  as_tibble() %>% 
  filter(solution_1 == 1)
mean((zz$penalty))[1]

s1_plot <- s1 %>% 
  st_as_sf(sf_column_name = 'geometry') %>% 
  mutate(solution_1 = as.logical(solution_1))
ggplot() +
  geom_sf(data = s1_plot, aes(fill = solution_1), color = 'grey20', size = 0.02) +
  scale_fill_manual(name = "Solution",
                    values = pal_rich,
                    labels = solution) +
  labs(title = 'scale = 4')


# created a loop to show how cost and RCE (or values vary with increasing penalty)
i = 1
j = 1
empty_df <- list()
for(i in 1:100) {
  
  scale <- i
  p1 <- p %>% 
    add_linear_penalties(i, 'penalty')
  s1 <- solve(p1)
  cost <- eval_cost_summary(p1, s1[,'solution_1'])[2]
  zz <- s1 %>% 
    as_tibble() %>% 
    filter(solution_1 == 1)
  RCE <- mean((zz$penalty)^3)[1] # cubeit because it's in cuberooted form
  
  empty_df[[j]] <- cbind(scale, cost, RCE)
  
  if(i == 1) {i = 5}
  else{i = i + 5}
  j <- j + 1
  
}

final_df <- bind_rows(empty_df)
final_df

# plotting
cost <- ggplot() +
  geom_line(data = final_df, aes(x = scale, y = cost)) +
  theme_bw()
RCE <- ggplot() +
  geom_line(data = final_df, aes(x = scale, y = RCE)) +
  theme_bw()
cost + RCE +
  plot_annotation(tag_levels = 'a')


# creating penalties use velocity
velocity <- readRDS('outputs/07_Climate/velocity/velocitySSP126.rds')
velocity_temp <- velocity %>% 
  as_tibble() %>% 
  dplyr::select(-area_km2, -trans_value, -velo_categ, -geometry)
velocity_temp

#### just trying 2 penalties

# creating a numeric list of the RCE values as penalty arranged according to cellsID
velocity_penalty_temp <- velocity_temp %>% 
  dplyr::arrange(cellsID)
velocity_penalty <- velocity_penalty_temp$value 

p3 <- prioritizr::problem(x, features_list, "cost") %>% 
  add_min_set_objective() %>%
  add_relative_targets(0.3) %>%
  add_binary_decisions() %>% 
  add_linear_penalties(1, RCE_penalty) %>% 
  add_linear_penalties(1, velocity_penalty) %>% 
  add_gurobi_solver(gap = 0, verbose = FALSE)

s3 <- solve(p3) %>% 
  st_as_sf(sf_column_name = "geometry") %>%  # Output changes from sf to df so we change it back
  mutate(solution_1 = as.logical(solution_1))

ggplot() +
  geom_sf(data = s3, aes(fill = solution_1), color = 'grey20', size = 0.02) +
  scale_fill_manual(name = "Solution",
                    values = pal_rich,
                    labels = solution) +
  labs(title = 'RCE penalty = 1; velocity penalty = 1; cost = same')
